"""
 _____                                                                       _____ 
( ___ )                                                                     ( ___ )
 |   |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|   | 
 |   |                                                                       |   | 
 |   |   ________  ________                ________  ________  _________     |   | 
 |   |  |\   __  \|\   __  \              |\   ____\|\   __  \|\___   ___\   |   | 
 |   |  \ \  \|\  \ \  \|\  \ ____________\ \  \___|\ \  \|\  \|___ \  \_|   |   | 
 |   |   \ \   _  _\ \   ____\\____________\ \  \  __\ \   ____\   \ \  \    |   | 
 |   |    \ \  \\  \\ \  \___\|____________|\ \  \|\  \ \  \___|    \ \  \   |   | 
 |   |     \ \__\\ _\\ \__\                  \ \_______\ \__\        \ \__\  |   | 
 |   |      \|__|\|__|\|__|                   \|_______|\|__|         \|__|  |   | 
 |   |                                                                       |   | 
 |___|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|___| 
(_____)                                                                     (_____)
################################################################################
#         Gemma-Orchestrated Roleplaying Journey  �  v0.1                      #
#         "Focused Evolution � Living Journal � Clean Outcome"                 #
################################################################################

       Wizard             Knight                  Rogue                  Drake
        /^\
       /___\            .-'''-.                .---.                 /^\
      ( o o )           |     |               ( o o )               ( . . )
       | ^ |           /|[_]| |\             _\  -  /_              | ^ ^
      /_\=/_\         /_/     \_\           /_/|   |\_\            /_\=/_\
        /_\                                  /       \              /_\

**Narrator:**  
?? Greetings, adventurer! This is **RP-GPT**�your AI Dungeon Master, loyal scribe, and sometimes snarky questgiver.  
Whether you�re a brave knight, a chaotic wizard, or someone who spends more time stealing boots than actually wearing them, you�re in the right place.  
Let�s keep it light, let�s keep it legendary, and remember: in this world, the worst roll is the one you don�t take. ??

---

## What is RP-GPT? ?????

RP-GPT 0.1 is a hybrid text adventure and AI-orchestrated RPG engine built for fast, focused, and creative roleplaying�alone or with friends at the keyboard.  
It mixes turn-based adventure with story-driven journals, campfire interludes, and a *Gemma-powered* prompt engine that adapts to your choices, your worldbuilding, and your party�s evolving mythos.  
Think Zork, but with improv. Think D&D, but your DM never needs a nap.


                ___
   .----.      __) `\
   | == |     < __=- |
___| :: |___   \\ `)/
\  `----'  /\  (\) (
 \   `.   /( \/ /\\
 |    :   | \  /  \\
 \   _._  /  `"   <_>
 
----------------------------------------------

             _,._
 .||,       /_ _\\
\.`',/      |'L'| |
= ,. =      | -,| L
/ || \    ,-'\"/,'`.
  ||     ,'   `,,. `.
  ,|____,' , ,;' \| |
 (3|\    _/|/'   _| |
  ||/,-''  | >-'' _,\\
  ||'      ==\ ,-'  ,'
  ||       |  V \ ,|
  ||       |    |` |
  ||       |    |   \
  ||       |    \    \
  ||       |     |    \
  ||       |      \_,-'
  ||       |___,,--")_\
  ||         |_|   ccc/
  ||        ccc/
  ||             
------------------------------------------------



                 _ _
          _     //` `\
      _,-"\%   // /``\`\
 ~^~ >__^  |% // /  } `\`\
        )  )%// / }  } }`\`\
       /  (%/'/.\_/\_/\_/\`/
      (    '         `-._`
       \   ,     (  \   _`-.__.-;%>
      /_`\ \      `\ \." `-..-'`
     ``` /_/`"-=-'`/_/
------------------------------------------------



---

## Features (a.k.a. �What does this do?�) ??

- **Scenario Setup:** Choose from classic tropes or invent your own: Apocalypse, Dark Fantasy, Haunted House, or something weird you just made up.
- **World Bible:** Feed in campaign notes or long-form lore. They�ll echo back through the journey and appear in your living journal.
- **Acts & Turns:** Every campaign is split into acts; each act is a loop of choices, encounters, and narrative turns.
- **Clean Prose:** Story output is in coherent, paragraph-long blocks�no broken lines, no awkwardly hyphenated words, no meter spam.
- **Dynamic Journal:** After every turn and fight, your journey is chronicled in a growing, natural-language adventure log. ??
- **NPCs & Dialogue:** New faces are scanned from the story and join the cast instantly. Each one has species, archetype, style, and sometimes secrets.
- **Conversation First:** Talking to an NPC never burns a turn�jabber as much as you like before doing something rash.
- **Microplan Action Engine:** Option menus draw from a �what�s relevant now?� microplan, nudging you toward plot without hiding cool stuff.
- **Goal Evolution:** Once you�re halfway to a quest�s goal, the pace and drama ramp up. Every win pushes you further.
- **Rest & Recovery:** Succeed, and you may be offered a moonlit camp interlude: celebrate, rest, ponder, dream, or just plot your next move. ??
- **UI & Presentation:** Play in the terminal or launch a pygame UI. Enjoy atmospheric music and on-the-fly image events (no downloads!).
- **Stable Turns:** Each round ends with a single [press enter] beat for rhythm. No chaos, no missed turns.
- **Error Handling:** Game tries to fail gracefully. Session lost? Resume or restart as needed.

---

## System Map ???

                                           !_
                                                  |*~=-.,
                                                  |_,-'`
                                                  |
                                                  |
                                                 /^\
                   !_                           /   \
                   |*`~-.,                     /,    \
                   |.-~^`                     /#"     \
                   |                        _/##_   _  \_
              _   _|  _   _   _            [ ]_[ ]_[ ]_[ ]
             [ ]_[ ]_[ ]_[ ]_[ ]            |_=_-=_ - =_|
           !_ |_=_ =-_-_  = =_|           !_ |=_= -    |
           |*`--,_- _        |            |*`~-.,= []  |
           |.-'|=     []     |   !_       |_.-"`_-     |
           |   |_=- -        |   |*`~-.,  |  |=_-      |
          /^\  |=_= -        |   |_,-~`  /^\ |_ - =[]  |
      _  /   \_|_=- _   _   _|  _|  _   /   \|=_-      |
     [ ]/,    \[ ]_[ ]_[ ]_[ ]_[ ]_[ ]_/,    \[ ]=-    |
      |/#"     \_=-___=__=__- =-_ -=_ /#"     \| _ []  |
     _/##_   _  \_-_ =  _____       _/##_   _  \_ -    |\
    [ ]_[ ]_[ ]_[ ]=_0~{_ _ _}~0   [ ]_[ ]_[ ]_[ ]=-   | \
    |_=__-_=-_  =_|-=_ |  ,  |     |_=-___-_ =-__|_    |  \
     | _- =-     |-_   | ((* |      |= _=       | -    |___\
     |= -_=      |=  _ |  `  |      |_-=_       |=_    |/+\|
     | =_  -     |_ = _ `-.-`       | =_ = =    |=_-   ||+||
     |-_=- _     |=_   =            |=_= -_     |  =   ||+||
     |=_- /+\    | -=               |_=- /+\    |=_    |^^^|
     |=_ |+|+|   |= -  -_,--,_      |_= |+|+|   |  -_  |=  |
     |  -|+|+|   |-_=  / |  | \     |=_ |+|+|   |-=_   |_-/
     |=_=|+|+|   | =_= | |  | |     |_- |+|+|   |_ =   |=/
     | _ ^^^^^   |= -  | |  <&>     |=_=^^^^^   |_=-   |/
     |=_ =       | =_-_| |  | |     |   =_      | -_   |
     |_=-_       |=_=  | |  | |     |=_=        |=-    |
^^^^^^^^^^`^`^^`^`^`^^^""""""""^`^^``^^`^^`^^`^`^``^`^``^``^^

"""


from __future__ import annotations
import json, random, re, sys
from dataclasses import dataclass, field
from enum import Enum, auto
from typing import Dict, List, Optional, Tuple, Any, Literal

from Core.Music import init_music
from Core.Helpers import (
    wrap,
    sanitize_prose,
    summarize_for_prompt,
    verbish_from_microplan,
    infer_species_and_comm_style,
    role_style_hint,
    personality_roll,
    journal_add,
    journal_lore_line,
)
from Core.Image_Gen import (
    make_player_portrait_prompt,
    make_actor_portrait_prompt,
    make_act_transition_prompt,
    make_act_start_prompt,
    make_startup_prompt,
    make_ending_prompt,
    make_combat_image_prompt,
    generate_turn_image,
    pollinations_url,
)
from Core.Interactions import (
    pick_actor,
    talk_loop,
    combat_turn,
    use_item,
)
from Core.Terminal_HUD import header, hud
from Core.AI_Dungeon_Master import (
    GemmaError,
    GemmaClient,
    campaign_blueprint_prompt,
    world_journal_prompt,
    turn_narration_prompt,
    recap_prompt,
    talk_reply_prompt,
    observe_prompt,
    combat_observe_prompt,
    option_microplans_prompt,
    custom_action_outcome_prompt,
    next_situation_prompt,
    set_extra_world_text,
    get_extra_world_text,
)
from Core.Random_Encounters import (
    try_discover_actor,
    encounter_flavor_prompt,
    handle_post_turn_beat,
)
from Core.Interludes import (
    celebrate_break,
    camp_interlude,
)
from Core.Journal import (
    maybe_journal_lore,
)
from Core.Scene_Evolution import (
    scan_for_new_actor,
    evolve_situation,
)
from Core.Character_Registry import (
    ensure_character_profile,
    register_default_characters,
    update_character_portrait,
    lookup_profile,
)

register_default_characters()
from Core.Turn_And_Act_Flow import (
    begin_act,
    end_of_turn,
    end_act_needed,
    recap_and_transition,
    try_advance,
    last_chance,
    game_loop,
)
from Core.Choice_Handler import (
    ExploreOptions,
    goal_lock_active,
    make_explore_options,
    render_menu,
    process_choice,
    ensure_custom_stat_per_turn,
    open_journal,
)

# When running this file as a script (__main__), modules that dynamically
# import 'RP_GPT' (e.g., Core.Turn_And_Act_Flow via _core()) might otherwise
# get a second module instance. That breaks Enum identity checks (like TurnMode)
# and can cause logic like `state.mode == TurnMode.EXPLORE` to fail.
# This alias ensures everyone sees the same module object.
if __name__ == "__main__":
    sys.modules.setdefault("RP_GPT", sys.modules[__name__])

# =============================
# ---------- CONFIG -----------
# =============================

ENABLE_TURN_IMAGE = True
IMG_WIDTH, IMG_HEIGHT = 768, 432
PORTRAIT_IMG_WIDTH, PORTRAIT_IMG_HEIGHT = 300, 300
IMG_TIMEOUT = 50

# Pick how the game launches. Change to "ui" or "prompt" if needed.
RUN_INTERFACE: Literal["terminal", "ui", "prompt"] = "ui"

try:
    import certifi
except Exception:
    certifi = None

# =============================
# ---------- PLAYER AND GAME STATES ----------
# =============================

class Scenario(Enum):
    APOCALYPSE = "Apocalypse"
    DARK_FANTASY = "Dark Fantasy"
    HAUNTED_HOUSE = "Haunted House"
    CUSTOM = "Custom"

class TurnMode(Enum):
    EXPLORE = auto()
    COMBAT = auto()
    TALK = auto()

SPECIAL_KEYS = ["STR","PER","END","CHA","INT","AGI","LUC"]

@dataclass
class Stats:
    STR:int=5; PER:int=5; END:int=5; CHA:int=5; INT:int=5; AGI:int=5; LUC:int=5
    @classmethod
    def random_special(cls, lo=3, hi=8):
        r=lambda: random.randint(lo,hi); return cls(r(),r(),r(),r(),r(),r(),r())

@dataclass
class Buff:
    name:str; duration_turns:int; stat_mods:Dict[str,int]=field(default_factory=dict)

@dataclass
class Item:
    name:str; tags:List[str]=field(default_factory=list)
    hp_delta:int=0; attack_delta:int=0; special_mods:Dict[str,int]=field(default_factory=dict)
    goal_delta:int=0; pressure_delta:int=0; consumable:bool=True; notes:str=""

@dataclass
class Actor:
    name:str; kind:str; hp:int=10; attack:int=2; disposition:int=0; personality:str=""
    role:str="npc"  # "npc","enemy","companion"
    discovered:bool=False
    alive:bool=True
    desc:str=""     # visual
    bio:str=""      # world journal bio
    # New tags for dialogue & behavior
    species:str="human"             # human, mutant, animal, synthetic, etc.
    comm_style:str="speech"         # speech, limited, animal, gestures
    personality_archetype:str=""    # joyful, inquisitive, stoic, aggressive, etc.
    aware:bool=True                 # whether NPC has detected the player
    stalks:bool=False               # whether NPC persists if you Leave
    ephemeral:bool=False            # lightweight/by-encounter only
    portrait_path: Optional[str] = None
    profile_folder: Optional[str] = None
    profile_metadata: Dict[str, Any] = field(default_factory=dict)

@dataclass
class Player:
    name:str="Explorer"; hp:int=100; attack:int=5; stats:Stats=field(default_factory=Stats.random_special)
    inventory:List[Item]=field(default_factory=list); buffs:List[Buff]=field(default_factory=list)
    age: Optional[int] = None; sex: Optional[str] = None; hair_color: Optional[str] = None
    clothing: Optional[str] = None; appearance: Optional[str] = None
    def effective_stat(self,k): 
        base=getattr(self.stats,k)
        return base+sum(b.stat_mods.get(k,0) for b in self.buffs)
    def add_item(self,it:Item):
        self.inventory.append(it)
        if it.attack_delta and "weapon" in it.tags: 
            self.attack+=it.attack_delta

@dataclass
class ActPlan:
    goal:str; intro_paragraph:str; pressure_evolution:str
    suggested_encounters:List[str]=field(default_factory=list)
    seed_actors:List[Dict[str,Any]]=field(default_factory=list)
    seed_items:List[Dict[str,Any]]=field(default_factory=list)

@dataclass
class CampaignBlueprint:
    campaign_goal:str; pressure_name:str; pressure_logic:str; acts:Dict[int,ActPlan]

@dataclass
class ActState:
    index:int
    turns_taken:int=1
    turn_cap:int=field(default_factory=lambda: random.randint(8,13))
    goal_progress:int=0
    situation:str=""
    actors:List[Actor]=field(default_factory=list)
    undiscovered:List[Actor]=field(default_factory=list)
    last_outcome:Optional[str]=None
    custom_uses:int=0

@dataclass
class ImageEvent:
    kind: Literal["startup","player_portrait","act_transition","act_start","turn","portrait","combat","ending"]
    act_index: int; turn_index: int; prompt: str
    actors: List[str] = field(default_factory=list)
    extra: Dict[str, Any] = field(default_factory=dict)

def queue_image_event(state:'GameState', kind:str, prompt:str, actors:Optional[List[str]]=None, extra:Optional[Dict[str,Any]]=None):
    evt = ImageEvent(
        kind=kind,
        act_index=state.act.index if state and state.act else 1,
        turn_index=state.act.turns_taken if state and state.act else 1,
        prompt=prompt, actors=list(actors or []), extra=dict(extra or {})
    )
    state.image_events.append(evt)
    try:
        with open("./image_events.jsonl","a",encoding="utf-8") as f:
            f.write(json.dumps({
                "kind":evt.kind,"act_index":evt.act_index,"turn_index":evt.turn_index,
                "prompt":evt.prompt,"actors":evt.actors,"extra":evt.extra
            })+"\n")
    except Exception:
        pass

@dataclass
class GameState:
    scenario:Scenario; scenario_label:str; player:Player; blueprint:CampaignBlueprint
    pressure_name:str; pressure:int=0; mode:TurnMode=TurnMode.EXPLORE
    act:ActState=field(default_factory=lambda: ActState(1)); act_count:int=3
    running:bool=True; debug:bool=False; last_enemy:Optional[Actor]=None
    custom_stat:Optional[str]=None; combat_turn_already_counted:bool=False
    history:List[str]=field(default_factory=list)
    turn_narrative_cache:Optional[str]=None
    combined_turn_text:Optional[str]=None
    last_custom_intent:Optional[str]=None
    last_shown_turn:int=-1
    scene_phase:int=0
    stall_count:int=0
    companions:List[Actor]=field(default_factory=list)
    images_enabled:bool=ENABLE_TURN_IMAGE
    last_image_path:Optional[str]=None
    last_image_url:Optional[str]=None
    last_actor:Optional[Actor]=None
    location_desc:str=""
    image_events: List[ImageEvent] = field(default_factory=list)
    world_metadata: Dict[str, Any] = field(default_factory=dict)
    world_folder: Optional[str] = None
    turns_per_act_override: Optional[int] = None
    # NEW: evolution focus + last printed paras (for option bias)
    last_result_para:str=""
    last_situation_para:str=""
    last_turn_success:bool=False
    # NEW: World Journal
    journal:List[str]=field(default_factory=list)
    journal_entry_count:int=0
    player_bio_entries:List[str]=field(default_factory=list)
    # NEW: per-turn flags
    rested_this_turn:bool=False
    # NEW: passive bystanders that didn't detect you
    passive_bystanders:List[str]=field(default_factory=list)

    def is_game_over(self)->Optional[str]:
        if self.player.hp<=0: return "You died."
        if self.pressure>=100: return f"{self.pressure_name} overwhelmed you."
        return None

# =============================
# ---------- GEMMA ------------
# =============================

_GEMMA: Optional[GemmaClient] = None

# =============================
# ---------- DICE -------------
# =============================

def d20(): return random.randint(1, 20)
def calc_dc(state, base: int = 12, extra: int = 0) -> int:
    return base + state.act.index + state.scene_phase + state.stall_count + (state.pressure // 25) + extra
def check(state:GameState, stat: str, dc: int) -> Tuple[bool, int]:
    val = state.player.effective_stat(stat)
    first = d20(); nat = first
    luck = max(0, state.player.effective_stat("LUC") - 5); p = min(0.30, luck / 40.0)
    roll = max(first, d20()) if random.random() < p else first
    total = roll + val
    if nat == 1: return False, total
    if nat == 20: return True, total
    return total >= dc, total

# =============================
# ---------- SETUP ------------
# =============================

def pick_scenario()->Tuple[Scenario,str]:
    print("Select a scenario:\n  [1] Apocalypse\n  [2] Dark Fantasy\n  [3] Haunted House\n  [4] Custom")
    while True:
        c=input("> ").strip()
        if c=="1": return Scenario.APOCALYPSE, Scenario.APOCALYPSE.value
        if c=="2": return Scenario.DARK_FANTASY, Scenario.DARK_FANTASY.value
        if c=="3": return Scenario.HAUNTED_HOUSE, Scenario.HAUNTED_HOUSE.value
        if c=="4": 
            lbl=input("Custom label (e.g., Sky Citadel, Clockwork Noir): ").strip() or "Custom"
            return Scenario.CUSTOM, lbl
        print("Please enter 1–4.")

def prompt_extra_world_details()->str:
    print("\nAdd long-form world details? (y/N)")
    ans = (input("> ").strip().lower() or "n")
    if ans!="y": return ""
    print("Paste world/campaign details (end with a blank line):")
    lines=[]
    while True:
        ln=input()
        if ln.strip()=="" and lines:
            break
        lines.append(ln)
    return "\n".join(lines).strip()

def init_player()->Player:
    name=input("Your name, wanderer? (blank for 'Explorer'): ").strip() or "Explorer"
    try:
        age_in = input("Age (optional): ").strip(); age = int(age_in) if age_in.isdigit() else None
    except Exception: age = None
    sex = (input("Sex (optional): ").strip() or None)
    hair = (input("Hair color (optional): ").strip() or None)
    clothing = (input("Clothing (optional): ").strip() or None)
    appearance = (input("General appearance (optional): ").strip() or None)
    p=Player(name=name, age=age, sex=sex, hair_color=hair, clothing=clothing, appearance=appearance)
    for it in [
        Item("Canteen",["food"],hp_delta=12,notes="Basic recovery"),
        Item("Rusty Knife",["weapon"],attack_delta=2,consumable=False,notes="Better than bare hands"),
        Item("Old Journal",["book","boon"],special_mods={"INT":+1},notes="Sparks insight")
    ]: p.add_item(it)
    return p

def items_from_seed(seed)->List[Item]:
    out=[]
    for i in seed or []:
        out.append(Item(
            name=i.get("name","Curio"), tags=i.get("tags",[]) or [],
            hp_delta=int(i.get("hp_delta",0)), attack_delta=int(i.get("attack_delta",0)),
            special_mods=i.get("special_mods",{}) or {}, goal_delta=int(i.get("goal_delta",0)),
            pressure_delta=int(i.get("pressure_delta",0)), consumable=bool(i.get("consumable",True)),
            notes=i.get("notes","")
        ))
    return out

def role_from_kind(kind:str)->str:
    low=kind.lower()
    if any(k in low for k in ["raider","bandit","goblin","spirit","monster","beast","shaman","soldier","assassin","cult","demon","ghoul"]):
        return "enemy"
    return "npc"

def actors_from_seed(seed, act_index:int)->List[Actor]:
    out=[]
    for a in seed or []:
        role=role_from_kind(a.get("kind","npc"))
        base_hp=int(a.get("hp",14)); base_atk=int(a.get("attack",3))
        hp=base_hp + (act_index-1)*6 + (4 if role=="enemy" else 0)
        atk=base_atk + (act_index-1)*1 + (1 if role=="enemy" else 0)
        species,comm=infer_species_and_comm_style(a.get("kind","npc"))
        actor = Actor(
            name=a.get("name","Stranger"), kind=a.get("kind","npc"),
            hp=hp, attack=atk, disposition=int(a.get("disposition",0)),
            personality=a.get("personality",""), role=role, discovered=False, alive=True,
            desc=a.get("personality",""),
            species=species, comm_style=comm, personality_archetype=personality_roll()
        )
        ensure_character_profile(actor)
        out.append(actor)
    return out

def json_to_actplan(d:Dict[str,Any])->ActPlan:
    return ActPlan(
        goal=d.get("goal",""), intro_paragraph=d.get("intro_paragraph",""),
        pressure_evolution=d.get("pressure_evolution",""),
        suggested_encounters=d.get("suggested_encounters",[]) or [],
        seed_actors=d.get("seed_actors",[]) or [], seed_items=d.get("seed_items",[]) or []
    )

def blueprint_from_json(j:Dict[str,Any])->CampaignBlueprint:
    raw_acts = j.get("acts") or {}
    acts: Dict[int, ActPlan] = {}
    for key, payload in raw_acts.items():
        try:
            idx = int(key)
        except Exception:
            continue
        acts[idx] = json_to_actplan(payload)
    if not acts:
        raise ValueError("Blueprint JSON missing acts")
    return CampaignBlueprint(
        campaign_goal=j["campaign_goal"],
        pressure_name=j["pressure_name"],
        pressure_logic=j.get("pressure_logic", ""),
        acts=acts,
    )

def get_blueprint_interactive(g:GemmaClient, label:str, overrides: Optional[Dict[str, object]] = None)->CampaignBlueprint:
    while True:
        try:
            g.check_or_pull_model()
            prompt = campaign_blueprint_prompt(label, overrides)
            j=g.json(prompt, tag="Blueprint")
            bp=blueprint_from_json(j)
            if not bp.acts:
                raise GemmaError('Blueprint contained no acts.')
            for idx in sorted(bp.acts.keys()):
                ap=bp.acts[idx]
                if not ap.goal or not ap.intro_paragraph:
                    raise GemmaError(f'Act {actual_idx} missing goal/intro.')
            print("[Gemma] Blueprint OK.")
            return bp
        except Exception as e:
            print("\n[ERROR] Blueprint generation failed:")
            print(f"  {e}")
            sel=(input("Options: [R]etry  [C]hange model  [Q]uit > ").strip().lower() or "r")
            if sel=="q": sys.exit(1)
            if sel=="c": g.model=input("New model tag > ").strip() or g.model

def begin_act(state:GameState, idx:int):
    acts = state.blueprint.acts
    if not acts:
        raise ValueError('Blueprint missing acts')
    actual_idx = idx if idx in acts else max(acts.keys())
    plan = acts[actual_idx]
    state.act = ActState(index=actual_idx)
    if state.turns_per_act_override:
        state.act.turn_cap = state.turns_per_act_override
    state.act.situation=plan.intro_paragraph
    state.location_desc = plan.intro_paragraph.split(".")[0] if plan.intro_paragraph else ""
    for it in items_from_seed(plan.seed_items):
        if random.random()<0.35: state.player.add_item(it)
    seeded=actors_from_seed(plan.seed_actors, actual_idx)
    if actual_idx==1:
        possible_companions=[
            Actor("Scout", "survivor", hp=18, attack=3, disposition=10, personality="pragmatic, loyal", role="companion", discovered=True, desc="scarred scout with keen eyes", bio="A wary scout who watches the ridgelines and rarely wastes words.", personality_archetype="stoic"),
            Actor("Sable", "rogue", hp=16, attack=4, disposition=0, personality="wry, opportunistic", role="companion", discovered=True, desc="lean thief with a sharp grin", bio="A quick-handed rogue who values leverage over loyalty.", personality_archetype="inquisitive"),
            Actor("Brutus", "dog", hp=14, attack=2, disposition=20, personality="protective, keen", role="companion", discovered=True, desc="shaggy dog with alert ears", bio="A loyal dog; communicates with posture, growls, and barks.", species="animal", comm_style="animal", personality_archetype="joyful")
        ]
        random.shuffle(possible_companions)
        num=random.choice([0,1,2])
        state.companions=possible_companions[:num]
        for c in state.companions:
            ensure_character_profile(c)
            state.act.actors.append(c)
            journal_add(state, f"{c.name} joined (companion). Bio: {c.bio}")
    state.act.undiscovered = seeded
    state.last_actor = state.companions[0] if state.companions else None
    state.history.append(f"Act {actual_idx} opened: {plan.goal}")
    try:
        intro_snippet = sanitize_prose(plan.intro_paragraph or plan.goal)
        if intro_snippet:
            state.player_bio_entries.append(f"Act {actual_idx}: {intro_snippet}")
    except Exception:
        pass
    journal_add(state, f"Act {actual_idx} begins: {plan.goal}")
    try:
        queue_image_event(state, "act_transition", make_act_transition_prompt(state, actual_idx), actors=[state.player.name], extra={"act": actual_idx})
        queue_image_event(state, "act_start", make_act_start_prompt(state, actual_idx), actors=[], extra={"act": actual_idx})
    except Exception:
        pass




# =============================
# ---------- LOOP -------------
# =============================

def game_loop_legacy(state:GameState, g:GemmaClient):
    while state.running:
        header(); hud(state)
        if state.act.turns_taken == 1:
            print("\n-- Situation --"); print(wrap(state.act.situation)); print()
        goal_lock = goal_lock_active(state, state.last_turn_success)

        if state.mode==TurnMode.EXPLORE:
            ex=make_explore_options(state, g, goal_lock); render_menu(state,ex)
            ch=input("> ").strip()
            consumed=process_choice(state,ch,ex,g)

            # Talking shouldn't burn a turn (requested change)
            if ch=="6":
                consumed=False

            if consumed:
                # After action output, pause for the single post-turn beat
                input("\n[Press Enter to continue]")

                # Celebration break: after a success, sometimes offer a quick rest/interlude.
                did_celebration_rest=False
                if state.last_turn_success:
                    did_celebration_rest = celebrate_break(state, g)

                # If the player explicitly Rested via [0], run the camp interlude now.
                if ch=="0":
                    camp_interlude(state, g)

                # Only spawn an encounter if the player didn't Rest or take the celebration rest
                if ch!="0" and not did_celebration_rest:
                    handle_post_turn_beat(state, g)

                # Advance time
                state.act.turns_taken+=1
                end_of_turn(state,g)

                # Append a short lore journal line most turns (non-spammy)
                maybe_journal_lore(state, g)

                if end_act_needed(state): 
                    recap_and_transition(state,g,"turn/end")

        elif state.mode==TurnMode.COMBAT:
            if not state.last_enemy or not state.last_enemy.alive or state.last_enemy.hp<=0:
                state.mode=TurnMode.EXPLORE; state.combat_turn_already_counted=False; continue
            _=combat_turn(state,state.last_enemy,g,goal_lock)

            input("\n[Press Enter to continue]")

            state.act.turns_taken+=1
            end_of_turn(state,g)

            # Append a short lore journal line after combat turns too
            maybe_journal_lore(state, g)

            if end_act_needed(state): 
                recap_and_transition(state,g,"turn/end")

        endmsg=state.is_game_over()
        if endmsg:
            print("\n"+endmsg)
            if state.player.hp<=0: print("\n"+wrap("Finale: The coil tightens. The world keeps what it has taken."))
            state.running=False



# =============================
# ---------- MAIN -------------
# =============================

def _resolve_interface_choice() -> str:
    '''Decide whether we boot the terminal loop or the pygame UI.'''
    # RUN_INTERFACE lets a developer flip between terminal, ui, or an interactive prompt.
    desired = (RUN_INTERFACE or "terminal").strip().lower()
    if desired == "prompt":
        print("[Mode] Pick how you want to play:")
        print("  [1] Terminal (default)")
        print("  [2] UI (pygame window)")
        while True:
            pick = input("> ").strip() or "1"
            if pick in {"1","terminal","t"}:
                return "terminal"
            if pick in {"2","ui","u"}:
                return "ui"
            print("Please press 1 for Terminal or 2 for UI.")
    if desired in {"terminal","ui"}:
        return desired
    print(f"[Mode] Unknown RUN_INTERFACE '{RUN_INTERFACE}'. Using terminal mode.")
    return "terminal"

def _run_terminal_game():
    global _GEMMA
    print("[Mode] Starting terminal interface.")
    print("="*78); print("RP-GPT6 — Gemma-Orchestrated RPG".center(78)); print("="*78)
    sc,label=pick_scenario()
    extra_world = prompt_extra_world_details()
    if extra_world:
        set_extra_world_text(extra_world)
    player=init_player()
    model=input("Gemma model for Ollama? (default gemma3:12b) > ").strip() or "gemma3:12b"
    g=GemmaClient(model=model); _GEMMA=g
    bp=get_blueprint_interactive(g,label)
    state=GameState(scenario=sc, scenario_label=label, player=player,
                    blueprint=bp, pressure_name=bp.pressure_name)
    begin_act(state,1)
    init_music()
    print("\n--- Adventure Begins ---\n")
    try:
        queue_image_event(state, "startup", make_startup_prompt(state), actors=[state.player.name], extra={"act":1})
        queue_image_event(state, "player_portrait", make_player_portrait_prompt(state.player), actors=[state.player.name], extra={"note":"initial portrait"})
    except Exception:
        pass
    game_loop(state,g)
    print("\nThanks for playing RP-GPT6.")

def main():
    choice = _resolve_interface_choice()
    if choice == "ui":
        print("[Mode] Starting UI (Main Menu).")
        from Core.Main_Menu import run_main_menu
        from pathlib import Path
        run_main_menu(Path(__file__).resolve().parent)
        return

    # Fall back to the original terminal loop.
    _run_terminal_game()

if __name__=="__main__":
    try: 
        main()
    except KeyboardInterrupt: 
        print("\nExiting RP-GPT6. Goodbye!")









